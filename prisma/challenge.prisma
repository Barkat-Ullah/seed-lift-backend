model Challenge {
  id            String             @id @default(auto()) @map("_id") @db.ObjectId
  challengeType ChallengeType
  title         String
  description   String
  category      ChallengeCategory?
  attachment    String?
  tags          String[]
  seedPoints    Int
  deadline      DateTime
  status        ChallengeStatus    @default(PENDING)
  isActive      Boolean            @default(true)
  isDeleted     Boolean            @default(false)
  isAwarded     Boolean            @default(false)
  inviteTalents String[]

  founderId String  @db.ObjectId
  founder   Founder @relation(fields: [founderId], references: [id])

  comment Comment[]
  react   React[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("challenge")

  @@index([status, isActive, isDeleted, isAwarded])
  @@index([category])
  @@index([challengeType])
}

model React {
  id          String @id @default(auto()) @map("_id") @db.ObjectId
  founderId   String @db.ObjectId
  seederId    String @db.ObjectId
  challengeId String @db.ObjectId

  isReact Boolean @default(false)

  challenge Challenge @relation(fields: [challengeId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([founderId, seederId, challengeId])
  @@map("love_react")
}

model Comment {
  id             String  @id @default(auto()) @map("_id") @db.ObjectId
  content        String
  image          String?
  seederId       String? @db.ObjectId
  founderId      String? @db.ObjectId
  challengeId    String  @db.ObjectId
  parentId       String? @db.ObjectId
  isFounderReply Boolean @default(false)
  isWin          Boolean @default(false)

  // Relations
  seeder    Seeder?    @relation(fields: [seederId], references: [id])
  founder   Founder?   @relation(fields: [founderId], references: [id])
  challenge Challenge? @relation(fields: [challengeId], references: [id])
  parent    Comment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  replies   Comment[]  @relation("CommentReplies")

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("comment")
}

enum ChallengeType {
  Public
  Private
}

enum ChallengeStatus {
  PENDING
  FINISHED
}

enum ChallengeCategory {
    Marketing_and_Growth
    Design_and_Creative
    Development_and_Tech
    Business_Strategy_and_Operation
    Finance_and_Investment
    Human_Resource_and_Culture
    Legal_and_Compliance
    Customer_Support_and_Communication
    Project_Management_and_Operations
    Creative_Writing_and_Content
    Learning_and_Education
    Innovation_and_Future
    General_and_Soft
    AI
    Others
}





// ============================================================================
// UPDATED PRISMA SCHEMA
// ============================================================================

/*
model React {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  founderId   String? @db.ObjectId  // ✅ Made optional
  seederId    String? @db.ObjectId  // ✅ Made optional
  challengeId String  @db.ObjectId
  userType    UserType              // ✅ Added to track who reacted

  isReact Boolean @default(false)

  challenge Challenge @relation(fields: [challengeId], references: [id])
  founder   Founder?  @relation(fields: [founderId], references: [id])
  seeder    Seeder?   @relation(fields: [seederId], references: [id])

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // ✅ Updated unique constraint to handle both cases
  @@unique([founderId, challengeId], name: "founder_challenge_react")
  @@unique([seederId, challengeId], name: "seeder_challenge_react")
  @@map("love_react")
}

enum UserType {
  FOUNDER
  SEEDER
}
*/

// ============================================================================
// SERVICE: CREATE/TOGGLE REACT (HANDLES BOTH FOUNDER AND SEEDER)
// ============================================================================

// const createReactIntoDb = async (
//   userEmail: string,
//   challengeId: string,
//   userType: 'FOUNDER' | 'SEEDER'
// ) => {
//   // Find user based on type
//   let user;
//   let userId;
//   let founderId = null;
//   let seederId = null;

//   if (userType === 'SEEDER') {
//     user = await prisma.seeder.findUnique({
//       where: { email: userEmail },
//     });
//     if (!user) {
//       throw new AppError(httpStatus.NOT_FOUND, 'Seeder not found');
//     }
//     seederId = user.id;
//   } else if (userType === 'FOUNDER') {
//     user = await prisma.founder.findUnique({
//       where: { email: userEmail },
//     });
//     if (!user) {
//       throw new AppError(httpStatus.NOT_FOUND, 'Founder not found');
//     }
//     founderId = user.id;
//   }

//   // Verify challenge exists
//   const challenge = await prisma.challenge.findUnique({
//     where: { id: challengeId },
//   });

//   if (!challenge) {
//     throw new AppError(httpStatus.NOT_FOUND, 'Challenge not found');
//   }

//   // Check existing react based on user type
//   const whereCondition =
//     userType === 'SEEDER'
//       ? { seederId_challengeId: { seederId: seederId!, challengeId } }
//       : { founderId_challengeId: { founderId: founderId!, challengeId } };

//   const existingReact = await prisma.react.findUnique({
//     where: whereCondition,
//   });

//   if (existingReact) {
//     // Toggle existing react
//     const newIsReact = !existingReact.isReact;
//     const result = await prisma.react.update({
//       where: { id: existingReact.id },
//       data: {
//         isReact: newIsReact,
//       },
//       select: {
//         id: true,
//         isReact: true,
//         userType: true,
//         createdAt: true,
//       },
//     });
//     return result;
//   }

//   // Create new react
//   const result = await prisma.react.create({
//     data: {
//       founderId,
//       seederId,
//       challengeId,
//       isReact: true,
//       userType,
//     },
//     select: {
//       id: true,
//       isReact: true,
//       userType: true,
//       createdAt: true,
//     },
//   });

//   return result;
// };

// // ============================================================================
// // CONTROLLER: SEEDER REACT
// // ============================================================================

// const seederReactChallenge = catchAsync(async (req: Request, res: Response) => {
//   const userEmail = req.user.email;
//   const { challengeId } = req.body;

//   const result = await createReactIntoDb(userEmail, challengeId, 'SEEDER');

//   sendResponse(res, {
//     statusCode: httpStatus.OK,
//     success: true,
//     message: result.isReact
//       ? 'Challenge reacted successfully'
//       : 'Challenge unreacted successfully',
//     data: result,
//   });
// });

// // ============================================================================
// // CONTROLLER: FOUNDER REACT
// // ============================================================================

// const founderReactChallenge = catchAsync(async (req: Request, res: Response) => {
//   const userEmail = req.user.email;
//   const { challengeId } = req.body;

//   const result = await createReactIntoDb(userEmail, challengeId, 'FOUNDER');

//   sendResponse(res, {
//     statusCode: httpStatus.OK,
//     success: true,
//     message: result.isReact
//       ? 'Challenge reacted successfully'
//       : 'Challenge unreacted successfully',
//     data: result,
//   });
// });

// // ============================================================================
// // ROUTES
// // ============================================================================

// // Seeder routes
// router.post(
//   '/seeder/react',
//   auth('SEEDER'),
//   SeederController.seederReactChallenge
// );

// // Founder routes
// router.post(
//   '/founder/react',
//   auth('FOUNDER'),
//   FounderController.founderReactChallenge
// );